// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(GldfFfi)
import GldfFfi
#elseif canImport(gldf_ffiFFI)
import gldf_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_gldf_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_gldf_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * GLDF Engine for parsing and manipulating GLDF files
 */
public protocol GldfEngineProtocol : AnyObject {
    
    /**
     * Add a file definition
     */
    func addFile(id: String, fileName: String, contentType: String, fileType: String) 
    
    /**
     * Extract raw file from archive by path
     */
    func getArchiveFile(path: String) throws  -> Data
    
    /**
     * Extract file content by file ID
     * Returns the binary content of the file from the GLDF archive
     */
    func getFileContent(fileId: String) throws  -> GldfFileContent
    
    /**
     * Extract file content as string (for text-based files like LDT, IES)
     */
    func getFileContentAsString(fileId: String) throws  -> String
    
    /**
     * Get all file definitions
     */
    func getFiles()  -> [GldfFile]
    
    /**
     * Get geometry (L3D) files
     */
    func getGeometryFiles()  -> [GldfFile]
    
    /**
     * Get header information
     */
    func getHeader()  -> GldfHeader
    
    /**
     * Get image files
     */
    func getImageFiles()  -> [GldfFile]
    
    /**
     * Get light sources (both fixed and changeable)
     */
    func getLightSources()  -> [GldfLightSource]
    
    /**
     * Get photometric files (LDT, IES)
     */
    func getPhotometricFiles()  -> [GldfFile]
    
    /**
     * Get statistics about the loaded GLDF
     */
    func getStats()  -> GldfStats
    
    /**
     * Get product variants
     */
    func getVariants()  -> [GldfVariant]
    
    /**
     * Check if raw archive data is available for file extraction
     */
    func hasArchiveData()  -> Bool
    
    /**
     * Check if the product has been modified
     */
    func isModified()  -> Bool
    
    /**
     * List all files in the archive with their paths
     */
    func listArchiveFiles() throws  -> [String]
    
    /**
     * Mark as saved (clears modified flag)
     */
    func markSaved() 
    
    /**
     * Remove a file by ID
     */
    func removeFile(id: String) 
    
    /**
     * Set the author
     */
    func setAuthor(author: String) 
    
    /**
     * Set the created with application
     */
    func setCreatedWithApplication(app: String) 
    
    /**
     * Set the creation time code
     */
    func setCreationTimeCode(timeCode: String) 
    
    /**
     * Set the default language
     */
    func setDefaultLanguage(language: String?) 
    
    /**
     * Set the format version
     */
    func setFormatVersion(major: Int32, minor: Int32, preRelease: Int32) 
    
    /**
     * Set the manufacturer
     */
    func setManufacturer(manufacturer: String) 
    
    /**
     * Export to JSON string
     */
    func toJson() throws  -> String
    
    /**
     * Export to pretty JSON string
     */
    func toPrettyJson() throws  -> String
    
    /**
     * Export to XML string
     */
    func toXml() throws  -> String
    
    /**
     * Update a file definition
     */
    func updateFile(id: String, fileName: String, contentType: String, fileType: String) 
    
}

/**
 * GLDF Engine for parsing and manipulating GLDF files
 */
open class GldfEngine:
    GldfEngineProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_gldf_ffi_fn_clone_gldfengine(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_gldf_ffi_fn_free_gldfengine(pointer, $0) }
    }

    
    /**
     * Create a new GLDF engine from raw GLDF file bytes (ZIP archive)
     */
public static func fromBytes(data: Data)throws  -> GldfEngine {
    return try  FfiConverterTypeGldfEngine.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_constructor_gldfengine_from_bytes(
        FfiConverterData.lower(data),$0
    )
})
}
    
    /**
     * Create a new GLDF engine from JSON string
     */
public static func fromJson(json: String)throws  -> GldfEngine {
    return try  FfiConverterTypeGldfEngine.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_constructor_gldfengine_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
    /**
     * Create a new empty GLDF engine
     */
public static func newEmpty() -> GldfEngine {
    return try!  FfiConverterTypeGldfEngine.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_constructor_gldfengine_new_empty($0
    )
})
}
    

    
    /**
     * Add a file definition
     */
open func addFile(id: String, fileName: String, contentType: String, fileType: String) {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_add_file(self.uniffiClonePointer(),
        FfiConverterString.lower(id),
        FfiConverterString.lower(fileName),
        FfiConverterString.lower(contentType),
        FfiConverterString.lower(fileType),$0
    )
}
}
    
    /**
     * Extract raw file from archive by path
     */
open func getArchiveFile(path: String)throws  -> Data {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_method_gldfengine_get_archive_file(self.uniffiClonePointer(),
        FfiConverterString.lower(path),$0
    )
})
}
    
    /**
     * Extract file content by file ID
     * Returns the binary content of the file from the GLDF archive
     */
open func getFileContent(fileId: String)throws  -> GldfFileContent {
    return try  FfiConverterTypeGldfFileContent.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_method_gldfengine_get_file_content(self.uniffiClonePointer(),
        FfiConverterString.lower(fileId),$0
    )
})
}
    
    /**
     * Extract file content as string (for text-based files like LDT, IES)
     */
open func getFileContentAsString(fileId: String)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_method_gldfengine_get_file_content_as_string(self.uniffiClonePointer(),
        FfiConverterString.lower(fileId),$0
    )
})
}
    
    /**
     * Get all file definitions
     */
open func getFiles() -> [GldfFile] {
    return try!  FfiConverterSequenceTypeGldfFile.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_get_files(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get geometry (L3D) files
     */
open func getGeometryFiles() -> [GldfFile] {
    return try!  FfiConverterSequenceTypeGldfFile.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_get_geometry_files(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get header information
     */
open func getHeader() -> GldfHeader {
    return try!  FfiConverterTypeGldfHeader.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_get_header(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get image files
     */
open func getImageFiles() -> [GldfFile] {
    return try!  FfiConverterSequenceTypeGldfFile.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_get_image_files(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get light sources (both fixed and changeable)
     */
open func getLightSources() -> [GldfLightSource] {
    return try!  FfiConverterSequenceTypeGldfLightSource.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_get_light_sources(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get photometric files (LDT, IES)
     */
open func getPhotometricFiles() -> [GldfFile] {
    return try!  FfiConverterSequenceTypeGldfFile.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_get_photometric_files(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get statistics about the loaded GLDF
     */
open func getStats() -> GldfStats {
    return try!  FfiConverterTypeGldfStats.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_get_stats(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get product variants
     */
open func getVariants() -> [GldfVariant] {
    return try!  FfiConverterSequenceTypeGldfVariant.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_get_variants(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if raw archive data is available for file extraction
     */
open func hasArchiveData() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_has_archive_data(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Check if the product has been modified
     */
open func isModified() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_is_modified(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * List all files in the archive with their paths
     */
open func listArchiveFiles()throws  -> [String] {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_method_gldfengine_list_archive_files(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Mark as saved (clears modified flag)
     */
open func markSaved() {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_mark_saved(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Remove a file by ID
     */
open func removeFile(id: String) {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_remove_file(self.uniffiClonePointer(),
        FfiConverterString.lower(id),$0
    )
}
}
    
    /**
     * Set the author
     */
open func setAuthor(author: String) {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_set_author(self.uniffiClonePointer(),
        FfiConverterString.lower(author),$0
    )
}
}
    
    /**
     * Set the created with application
     */
open func setCreatedWithApplication(app: String) {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_set_created_with_application(self.uniffiClonePointer(),
        FfiConverterString.lower(app),$0
    )
}
}
    
    /**
     * Set the creation time code
     */
open func setCreationTimeCode(timeCode: String) {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_set_creation_time_code(self.uniffiClonePointer(),
        FfiConverterString.lower(timeCode),$0
    )
}
}
    
    /**
     * Set the default language
     */
open func setDefaultLanguage(language: String?) {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_set_default_language(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(language),$0
    )
}
}
    
    /**
     * Set the format version
     */
open func setFormatVersion(major: Int32, minor: Int32, preRelease: Int32) {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_set_format_version(self.uniffiClonePointer(),
        FfiConverterInt32.lower(major),
        FfiConverterInt32.lower(minor),
        FfiConverterInt32.lower(preRelease),$0
    )
}
}
    
    /**
     * Set the manufacturer
     */
open func setManufacturer(manufacturer: String) {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_set_manufacturer(self.uniffiClonePointer(),
        FfiConverterString.lower(manufacturer),$0
    )
}
}
    
    /**
     * Export to JSON string
     */
open func toJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_method_gldfengine_to_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Export to pretty JSON string
     */
open func toPrettyJson()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_method_gldfengine_to_pretty_json(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Export to XML string
     */
open func toXml()throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_method_gldfengine_to_xml(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Update a file definition
     */
open func updateFile(id: String, fileName: String, contentType: String, fileType: String) {try! rustCall() {
    uniffi_gldf_ffi_fn_method_gldfengine_update_file(self.uniffiClonePointer(),
        FfiConverterString.lower(id),
        FfiConverterString.lower(fileName),
        FfiConverterString.lower(contentType),
        FfiConverterString.lower(fileType),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGldfEngine: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = GldfEngine

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> GldfEngine {
        return GldfEngine(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: GldfEngine) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GldfEngine {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: GldfEngine, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfEngine_lift(_ pointer: UnsafeMutableRawPointer) throws -> GldfEngine {
    return try FfiConverterTypeGldfEngine.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfEngine_lower(_ value: GldfEngine) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGldfEngine.lower(value)
}


/**
 * Parsed EULUMDAT photometric data
 */
public struct EulumdatData {
    /**
     * Manufacturer/Header string
     */
    public var manufacturer: String
    /**
     * Luminaire name
     */
    public var luminaireName: String
    /**
     * Luminaire number
     */
    public var luminaireNumber: String
    /**
     * Lamp type description
     */
    public var lampType: String
    /**
     * Total luminous flux in lumens
     */
    public var totalLumens: Double
    /**
     * Light Output Ratio Luminaire (%)
     */
    public var lorl: Double
    /**
     * Number of C planes
     */
    public var cPlaneCount: Int32
    /**
     * Number of gamma angles
     */
    public var gammaCount: Int32
    /**
     * Symmetry indicator (0-4)
     */
    public var symmetry: Int32
    /**
     * C plane angles in degrees
     */
    public var cAngles: [Double]
    /**
     * Gamma angles in degrees
     */
    public var gammaAngles: [Double]
    /**
     * Intensity values organized by C plane, then by gamma
     * Access as: intensities[c_plane_index * gamma_count + gamma_index]
     */
    public var intensities: [Double]
    /**
     * Maximum intensity value (for normalization)
     */
    public var maxIntensity: Double
    /**
     * Unit conversion factor
     */
    public var conversionFactor: Double
    /**
     * Luminaire dimensions in mm [length, width, height]
     */
    public var luminaireDimensions: [Double]
    /**
     * Luminous area dimensions in mm [length, width]
     */
    public var luminousAreaDimensions: [Double]
    /**
     * Downward flux fraction (%)
     */
    public var dff: Double
    /**
     * Color temperature (K)
     */
    public var colorTemperature: String
    /**
     * Wattage (W)
     */
    public var wattage: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Manufacturer/Header string
         */manufacturer: String, 
        /**
         * Luminaire name
         */luminaireName: String, 
        /**
         * Luminaire number
         */luminaireNumber: String, 
        /**
         * Lamp type description
         */lampType: String, 
        /**
         * Total luminous flux in lumens
         */totalLumens: Double, 
        /**
         * Light Output Ratio Luminaire (%)
         */lorl: Double, 
        /**
         * Number of C planes
         */cPlaneCount: Int32, 
        /**
         * Number of gamma angles
         */gammaCount: Int32, 
        /**
         * Symmetry indicator (0-4)
         */symmetry: Int32, 
        /**
         * C plane angles in degrees
         */cAngles: [Double], 
        /**
         * Gamma angles in degrees
         */gammaAngles: [Double], 
        /**
         * Intensity values organized by C plane, then by gamma
         * Access as: intensities[c_plane_index * gamma_count + gamma_index]
         */intensities: [Double], 
        /**
         * Maximum intensity value (for normalization)
         */maxIntensity: Double, 
        /**
         * Unit conversion factor
         */conversionFactor: Double, 
        /**
         * Luminaire dimensions in mm [length, width, height]
         */luminaireDimensions: [Double], 
        /**
         * Luminous area dimensions in mm [length, width]
         */luminousAreaDimensions: [Double], 
        /**
         * Downward flux fraction (%)
         */dff: Double, 
        /**
         * Color temperature (K)
         */colorTemperature: String, 
        /**
         * Wattage (W)
         */wattage: Double) {
        self.manufacturer = manufacturer
        self.luminaireName = luminaireName
        self.luminaireNumber = luminaireNumber
        self.lampType = lampType
        self.totalLumens = totalLumens
        self.lorl = lorl
        self.cPlaneCount = cPlaneCount
        self.gammaCount = gammaCount
        self.symmetry = symmetry
        self.cAngles = cAngles
        self.gammaAngles = gammaAngles
        self.intensities = intensities
        self.maxIntensity = maxIntensity
        self.conversionFactor = conversionFactor
        self.luminaireDimensions = luminaireDimensions
        self.luminousAreaDimensions = luminousAreaDimensions
        self.dff = dff
        self.colorTemperature = colorTemperature
        self.wattage = wattage
    }
}



extension EulumdatData: Equatable, Hashable {
    public static func ==(lhs: EulumdatData, rhs: EulumdatData) -> Bool {
        if lhs.manufacturer != rhs.manufacturer {
            return false
        }
        if lhs.luminaireName != rhs.luminaireName {
            return false
        }
        if lhs.luminaireNumber != rhs.luminaireNumber {
            return false
        }
        if lhs.lampType != rhs.lampType {
            return false
        }
        if lhs.totalLumens != rhs.totalLumens {
            return false
        }
        if lhs.lorl != rhs.lorl {
            return false
        }
        if lhs.cPlaneCount != rhs.cPlaneCount {
            return false
        }
        if lhs.gammaCount != rhs.gammaCount {
            return false
        }
        if lhs.symmetry != rhs.symmetry {
            return false
        }
        if lhs.cAngles != rhs.cAngles {
            return false
        }
        if lhs.gammaAngles != rhs.gammaAngles {
            return false
        }
        if lhs.intensities != rhs.intensities {
            return false
        }
        if lhs.maxIntensity != rhs.maxIntensity {
            return false
        }
        if lhs.conversionFactor != rhs.conversionFactor {
            return false
        }
        if lhs.luminaireDimensions != rhs.luminaireDimensions {
            return false
        }
        if lhs.luminousAreaDimensions != rhs.luminousAreaDimensions {
            return false
        }
        if lhs.dff != rhs.dff {
            return false
        }
        if lhs.colorTemperature != rhs.colorTemperature {
            return false
        }
        if lhs.wattage != rhs.wattage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manufacturer)
        hasher.combine(luminaireName)
        hasher.combine(luminaireNumber)
        hasher.combine(lampType)
        hasher.combine(totalLumens)
        hasher.combine(lorl)
        hasher.combine(cPlaneCount)
        hasher.combine(gammaCount)
        hasher.combine(symmetry)
        hasher.combine(cAngles)
        hasher.combine(gammaAngles)
        hasher.combine(intensities)
        hasher.combine(maxIntensity)
        hasher.combine(conversionFactor)
        hasher.combine(luminaireDimensions)
        hasher.combine(luminousAreaDimensions)
        hasher.combine(dff)
        hasher.combine(colorTemperature)
        hasher.combine(wattage)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEulumdatData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EulumdatData {
        return
            try EulumdatData(
                manufacturer: FfiConverterString.read(from: &buf), 
                luminaireName: FfiConverterString.read(from: &buf), 
                luminaireNumber: FfiConverterString.read(from: &buf), 
                lampType: FfiConverterString.read(from: &buf), 
                totalLumens: FfiConverterDouble.read(from: &buf), 
                lorl: FfiConverterDouble.read(from: &buf), 
                cPlaneCount: FfiConverterInt32.read(from: &buf), 
                gammaCount: FfiConverterInt32.read(from: &buf), 
                symmetry: FfiConverterInt32.read(from: &buf), 
                cAngles: FfiConverterSequenceDouble.read(from: &buf), 
                gammaAngles: FfiConverterSequenceDouble.read(from: &buf), 
                intensities: FfiConverterSequenceDouble.read(from: &buf), 
                maxIntensity: FfiConverterDouble.read(from: &buf), 
                conversionFactor: FfiConverterDouble.read(from: &buf), 
                luminaireDimensions: FfiConverterSequenceDouble.read(from: &buf), 
                luminousAreaDimensions: FfiConverterSequenceDouble.read(from: &buf), 
                dff: FfiConverterDouble.read(from: &buf), 
                colorTemperature: FfiConverterString.read(from: &buf), 
                wattage: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: EulumdatData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.manufacturer, into: &buf)
        FfiConverterString.write(value.luminaireName, into: &buf)
        FfiConverterString.write(value.luminaireNumber, into: &buf)
        FfiConverterString.write(value.lampType, into: &buf)
        FfiConverterDouble.write(value.totalLumens, into: &buf)
        FfiConverterDouble.write(value.lorl, into: &buf)
        FfiConverterInt32.write(value.cPlaneCount, into: &buf)
        FfiConverterInt32.write(value.gammaCount, into: &buf)
        FfiConverterInt32.write(value.symmetry, into: &buf)
        FfiConverterSequenceDouble.write(value.cAngles, into: &buf)
        FfiConverterSequenceDouble.write(value.gammaAngles, into: &buf)
        FfiConverterSequenceDouble.write(value.intensities, into: &buf)
        FfiConverterDouble.write(value.maxIntensity, into: &buf)
        FfiConverterDouble.write(value.conversionFactor, into: &buf)
        FfiConverterSequenceDouble.write(value.luminaireDimensions, into: &buf)
        FfiConverterSequenceDouble.write(value.luminousAreaDimensions, into: &buf)
        FfiConverterDouble.write(value.dff, into: &buf)
        FfiConverterString.write(value.colorTemperature, into: &buf)
        FfiConverterDouble.write(value.wattage, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEulumdatData_lift(_ buf: RustBuffer) throws -> EulumdatData {
    return try FfiConverterTypeEulumdatData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEulumdatData_lower(_ value: EulumdatData) -> RustBuffer {
    return FfiConverterTypeEulumdatData.lower(value)
}


/**
 * File definition from GLDF
 */
public struct GldfFile {
    public var id: String
    public var fileName: String
    public var contentType: String
    public var fileType: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, fileName: String, contentType: String, fileType: String) {
        self.id = id
        self.fileName = fileName
        self.contentType = contentType
        self.fileType = fileType
    }
}



extension GldfFile: Equatable, Hashable {
    public static func ==(lhs: GldfFile, rhs: GldfFile) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.contentType != rhs.contentType {
            return false
        }
        if lhs.fileType != rhs.fileType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(fileName)
        hasher.combine(contentType)
        hasher.combine(fileType)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGldfFile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GldfFile {
        return
            try GldfFile(
                id: FfiConverterString.read(from: &buf), 
                fileName: FfiConverterString.read(from: &buf), 
                contentType: FfiConverterString.read(from: &buf), 
                fileType: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GldfFile, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterString.write(value.contentType, into: &buf)
        FfiConverterString.write(value.fileType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfFile_lift(_ buf: RustBuffer) throws -> GldfFile {
    return try FfiConverterTypeGldfFile.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfFile_lower(_ value: GldfFile) -> RustBuffer {
    return FfiConverterTypeGldfFile.lower(value)
}


/**
 * Extracted file content from GLDF archive
 */
public struct GldfFileContent {
    public var fileId: String
    public var fileName: String
    public var contentType: String
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(fileId: String, fileName: String, contentType: String, data: Data) {
        self.fileId = fileId
        self.fileName = fileName
        self.contentType = contentType
        self.data = data
    }
}



extension GldfFileContent: Equatable, Hashable {
    public static func ==(lhs: GldfFileContent, rhs: GldfFileContent) -> Bool {
        if lhs.fileId != rhs.fileId {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.contentType != rhs.contentType {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fileId)
        hasher.combine(fileName)
        hasher.combine(contentType)
        hasher.combine(data)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGldfFileContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GldfFileContent {
        return
            try GldfFileContent(
                fileId: FfiConverterString.read(from: &buf), 
                fileName: FfiConverterString.read(from: &buf), 
                contentType: FfiConverterString.read(from: &buf), 
                data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: GldfFileContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.fileId, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterString.write(value.contentType, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfFileContent_lift(_ buf: RustBuffer) throws -> GldfFileContent {
    return try FfiConverterTypeGldfFileContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfFileContent_lower(_ value: GldfFileContent) -> RustBuffer {
    return FfiConverterTypeGldfFileContent.lower(value)
}


/**
 * Header information from GLDF file
 */
public struct GldfHeader {
    public var manufacturer: String
    public var author: String
    public var formatVersion: String
    public var createdWithApplication: String
    public var creationTimeCode: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(manufacturer: String, author: String, formatVersion: String, createdWithApplication: String, creationTimeCode: String) {
        self.manufacturer = manufacturer
        self.author = author
        self.formatVersion = formatVersion
        self.createdWithApplication = createdWithApplication
        self.creationTimeCode = creationTimeCode
    }
}



extension GldfHeader: Equatable, Hashable {
    public static func ==(lhs: GldfHeader, rhs: GldfHeader) -> Bool {
        if lhs.manufacturer != rhs.manufacturer {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.formatVersion != rhs.formatVersion {
            return false
        }
        if lhs.createdWithApplication != rhs.createdWithApplication {
            return false
        }
        if lhs.creationTimeCode != rhs.creationTimeCode {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manufacturer)
        hasher.combine(author)
        hasher.combine(formatVersion)
        hasher.combine(createdWithApplication)
        hasher.combine(creationTimeCode)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGldfHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GldfHeader {
        return
            try GldfHeader(
                manufacturer: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                formatVersion: FfiConverterString.read(from: &buf), 
                createdWithApplication: FfiConverterString.read(from: &buf), 
                creationTimeCode: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GldfHeader, into buf: inout [UInt8]) {
        FfiConverterString.write(value.manufacturer, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.formatVersion, into: &buf)
        FfiConverterString.write(value.createdWithApplication, into: &buf)
        FfiConverterString.write(value.creationTimeCode, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfHeader_lift(_ buf: RustBuffer) throws -> GldfHeader {
    return try FfiConverterTypeGldfHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfHeader_lower(_ value: GldfHeader) -> RustBuffer {
    return FfiConverterTypeGldfHeader.lower(value)
}


/**
 * Light source information (simplified - covers both fixed and changeable)
 */
public struct GldfLightSource {
    public var id: String
    public var name: String
    public var lightSourceType: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, lightSourceType: String) {
        self.id = id
        self.name = name
        self.lightSourceType = lightSourceType
    }
}



extension GldfLightSource: Equatable, Hashable {
    public static func ==(lhs: GldfLightSource, rhs: GldfLightSource) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.lightSourceType != rhs.lightSourceType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(lightSourceType)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGldfLightSource: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GldfLightSource {
        return
            try GldfLightSource(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                lightSourceType: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GldfLightSource, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.lightSourceType, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfLightSource_lift(_ buf: RustBuffer) throws -> GldfLightSource {
    return try FfiConverterTypeGldfLightSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfLightSource_lower(_ value: GldfLightSource) -> RustBuffer {
    return FfiConverterTypeGldfLightSource.lower(value)
}


/**
 * Statistics about loaded GLDF
 */
public struct GldfStats {
    public var filesCount: UInt64
    public var fixedLightSourcesCount: UInt64
    public var changeableLightSourcesCount: UInt64
    public var variantsCount: UInt64
    public var photometriesCount: UInt64
    public var simpleGeometriesCount: UInt64
    public var modelGeometriesCount: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(filesCount: UInt64, fixedLightSourcesCount: UInt64, changeableLightSourcesCount: UInt64, variantsCount: UInt64, photometriesCount: UInt64, simpleGeometriesCount: UInt64, modelGeometriesCount: UInt64) {
        self.filesCount = filesCount
        self.fixedLightSourcesCount = fixedLightSourcesCount
        self.changeableLightSourcesCount = changeableLightSourcesCount
        self.variantsCount = variantsCount
        self.photometriesCount = photometriesCount
        self.simpleGeometriesCount = simpleGeometriesCount
        self.modelGeometriesCount = modelGeometriesCount
    }
}



extension GldfStats: Equatable, Hashable {
    public static func ==(lhs: GldfStats, rhs: GldfStats) -> Bool {
        if lhs.filesCount != rhs.filesCount {
            return false
        }
        if lhs.fixedLightSourcesCount != rhs.fixedLightSourcesCount {
            return false
        }
        if lhs.changeableLightSourcesCount != rhs.changeableLightSourcesCount {
            return false
        }
        if lhs.variantsCount != rhs.variantsCount {
            return false
        }
        if lhs.photometriesCount != rhs.photometriesCount {
            return false
        }
        if lhs.simpleGeometriesCount != rhs.simpleGeometriesCount {
            return false
        }
        if lhs.modelGeometriesCount != rhs.modelGeometriesCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(filesCount)
        hasher.combine(fixedLightSourcesCount)
        hasher.combine(changeableLightSourcesCount)
        hasher.combine(variantsCount)
        hasher.combine(photometriesCount)
        hasher.combine(simpleGeometriesCount)
        hasher.combine(modelGeometriesCount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGldfStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GldfStats {
        return
            try GldfStats(
                filesCount: FfiConverterUInt64.read(from: &buf), 
                fixedLightSourcesCount: FfiConverterUInt64.read(from: &buf), 
                changeableLightSourcesCount: FfiConverterUInt64.read(from: &buf), 
                variantsCount: FfiConverterUInt64.read(from: &buf), 
                photometriesCount: FfiConverterUInt64.read(from: &buf), 
                simpleGeometriesCount: FfiConverterUInt64.read(from: &buf), 
                modelGeometriesCount: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: GldfStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.filesCount, into: &buf)
        FfiConverterUInt64.write(value.fixedLightSourcesCount, into: &buf)
        FfiConverterUInt64.write(value.changeableLightSourcesCount, into: &buf)
        FfiConverterUInt64.write(value.variantsCount, into: &buf)
        FfiConverterUInt64.write(value.photometriesCount, into: &buf)
        FfiConverterUInt64.write(value.simpleGeometriesCount, into: &buf)
        FfiConverterUInt64.write(value.modelGeometriesCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfStats_lift(_ buf: RustBuffer) throws -> GldfStats {
    return try FfiConverterTypeGldfStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfStats_lower(_ value: GldfStats) -> RustBuffer {
    return FfiConverterTypeGldfStats.lower(value)
}


/**
 * Product variant information
 */
public struct GldfVariant {
    public var id: String
    public var name: String
    public var description: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, description: String) {
        self.id = id
        self.name = name
        self.description = description
    }
}



extension GldfVariant: Equatable, Hashable {
    public static func ==(lhs: GldfVariant, rhs: GldfVariant) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(description)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGldfVariant: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GldfVariant {
        return
            try GldfVariant(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: GldfVariant, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfVariant_lift(_ buf: RustBuffer) throws -> GldfVariant {
    return try FfiConverterTypeGldfVariant.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGldfVariant_lower(_ value: GldfVariant) -> RustBuffer {
    return FfiConverterTypeGldfVariant.lower(value)
}


/**
 * Asset file extracted from L3D archive
 */
public struct L3dAsset {
    /**
     * File name/path in archive
     */
    public var name: String
    /**
     * File content (OBJ, MTL, textures)
     */
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * File name/path in archive
         */name: String, 
        /**
         * File content (OBJ, MTL, textures)
         */data: Data) {
        self.name = name
        self.data = data
    }
}



extension L3dAsset: Equatable, Hashable {
    public static func ==(lhs: L3dAsset, rhs: L3dAsset) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(data)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeL3dAsset: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> L3dAsset {
        return
            try L3dAsset(
                name: FfiConverterString.read(from: &buf), 
                data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: L3dAsset, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dAsset_lift(_ buf: RustBuffer) throws -> L3dAsset {
    return try FfiConverterTypeL3dAsset.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dAsset_lower(_ value: L3dAsset) -> RustBuffer {
    return FfiConverterTypeL3dAsset.lower(value)
}


/**
 * Face assignment for light emitting surfaces
 */
public struct L3dFaceAssignment {
    /**
     * Light emitting object part name
     */
    public var leoPartName: String
    /**
     * Starting face index
     */
    public var faceIndexBegin: Int32
    /**
     * Ending face index
     */
    public var faceIndexEnd: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Light emitting object part name
         */leoPartName: String, 
        /**
         * Starting face index
         */faceIndexBegin: Int32, 
        /**
         * Ending face index
         */faceIndexEnd: Int32) {
        self.leoPartName = leoPartName
        self.faceIndexBegin = faceIndexBegin
        self.faceIndexEnd = faceIndexEnd
    }
}



extension L3dFaceAssignment: Equatable, Hashable {
    public static func ==(lhs: L3dFaceAssignment, rhs: L3dFaceAssignment) -> Bool {
        if lhs.leoPartName != rhs.leoPartName {
            return false
        }
        if lhs.faceIndexBegin != rhs.faceIndexBegin {
            return false
        }
        if lhs.faceIndexEnd != rhs.faceIndexEnd {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(leoPartName)
        hasher.combine(faceIndexBegin)
        hasher.combine(faceIndexEnd)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeL3dFaceAssignment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> L3dFaceAssignment {
        return
            try L3dFaceAssignment(
                leoPartName: FfiConverterString.read(from: &buf), 
                faceIndexBegin: FfiConverterInt32.read(from: &buf), 
                faceIndexEnd: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: L3dFaceAssignment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.leoPartName, into: &buf)
        FfiConverterInt32.write(value.faceIndexBegin, into: &buf)
        FfiConverterInt32.write(value.faceIndexEnd, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dFaceAssignment_lift(_ buf: RustBuffer) throws -> L3dFaceAssignment {
    return try FfiConverterTypeL3dFaceAssignment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dFaceAssignment_lower(_ value: L3dFaceAssignment) -> RustBuffer {
    return FfiConverterTypeL3dFaceAssignment.lower(value)
}


/**
 * Complete L3D file with scene and assets
 */
public struct L3dFile {
    /**
     * Parsed scene information
     */
    public var scene: L3dScene
    /**
     * All assets (OBJ files, MTL files, textures)
     */
    public var assets: [L3dAsset]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Parsed scene information
         */scene: L3dScene, 
        /**
         * All assets (OBJ files, MTL files, textures)
         */assets: [L3dAsset]) {
        self.scene = scene
        self.assets = assets
    }
}



extension L3dFile: Equatable, Hashable {
    public static func ==(lhs: L3dFile, rhs: L3dFile) -> Bool {
        if lhs.scene != rhs.scene {
            return false
        }
        if lhs.assets != rhs.assets {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(scene)
        hasher.combine(assets)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeL3dFile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> L3dFile {
        return
            try L3dFile(
                scene: FfiConverterTypeL3dScene.read(from: &buf), 
                assets: FfiConverterSequenceTypeL3dAsset.read(from: &buf)
        )
    }

    public static func write(_ value: L3dFile, into buf: inout [UInt8]) {
        FfiConverterTypeL3dScene.write(value.scene, into: &buf)
        FfiConverterSequenceTypeL3dAsset.write(value.assets, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dFile_lift(_ buf: RustBuffer) throws -> L3dFile {
    return try FfiConverterTypeL3dFile.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dFile_lower(_ value: L3dFile) -> RustBuffer {
    return FfiConverterTypeL3dFile.lower(value)
}


/**
 * Geometry file definition in L3D
 */
public struct L3dGeometryDef {
    /**
     * Unique ID for this geometry
     */
    public var id: String
    /**
     * Filename of the OBJ file
     */
    public var filename: String
    /**
     * Units: "m", "mm", "in"
     */
    public var units: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Unique ID for this geometry
         */id: String, 
        /**
         * Filename of the OBJ file
         */filename: String, 
        /**
         * Units: "m", "mm", "in"
         */units: String) {
        self.id = id
        self.filename = filename
        self.units = units
    }
}



extension L3dGeometryDef: Equatable, Hashable {
    public static func ==(lhs: L3dGeometryDef, rhs: L3dGeometryDef) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        if lhs.units != rhs.units {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(filename)
        hasher.combine(units)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeL3dGeometryDef: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> L3dGeometryDef {
        return
            try L3dGeometryDef(
                id: FfiConverterString.read(from: &buf), 
                filename: FfiConverterString.read(from: &buf), 
                units: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: L3dGeometryDef, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterString.write(value.units, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dGeometryDef_lift(_ buf: RustBuffer) throws -> L3dGeometryDef {
    return try FfiConverterTypeL3dGeometryDef.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dGeometryDef_lower(_ value: L3dGeometryDef) -> RustBuffer {
    return FfiConverterTypeL3dGeometryDef.lower(value)
}


/**
 * Joint definition for articulated parts
 */
public struct L3dJoint {
    /**
     * Joint part name
     */
    public var partName: String
    /**
     * Position relative to parent
     */
    public var position: Vec3
    /**
     * Rotation in degrees
     */
    public var rotation: Vec3
    /**
     * Axis constraints
     */
    public var axis: L3dJointAxis?
    /**
     * Default rotation value (if specified)
     */
    public var defaultRotation: Vec3?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Joint part name
         */partName: String, 
        /**
         * Position relative to parent
         */position: Vec3, 
        /**
         * Rotation in degrees
         */rotation: Vec3, 
        /**
         * Axis constraints
         */axis: L3dJointAxis?, 
        /**
         * Default rotation value (if specified)
         */defaultRotation: Vec3?) {
        self.partName = partName
        self.position = position
        self.rotation = rotation
        self.axis = axis
        self.defaultRotation = defaultRotation
    }
}



extension L3dJoint: Equatable, Hashable {
    public static func ==(lhs: L3dJoint, rhs: L3dJoint) -> Bool {
        if lhs.partName != rhs.partName {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.rotation != rhs.rotation {
            return false
        }
        if lhs.axis != rhs.axis {
            return false
        }
        if lhs.defaultRotation != rhs.defaultRotation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(partName)
        hasher.combine(position)
        hasher.combine(rotation)
        hasher.combine(axis)
        hasher.combine(defaultRotation)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeL3dJoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> L3dJoint {
        return
            try L3dJoint(
                partName: FfiConverterString.read(from: &buf), 
                position: FfiConverterTypeVec3.read(from: &buf), 
                rotation: FfiConverterTypeVec3.read(from: &buf), 
                axis: FfiConverterOptionTypeL3dJointAxis.read(from: &buf), 
                defaultRotation: FfiConverterOptionTypeVec3.read(from: &buf)
        )
    }

    public static func write(_ value: L3dJoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.partName, into: &buf)
        FfiConverterTypeVec3.write(value.position, into: &buf)
        FfiConverterTypeVec3.write(value.rotation, into: &buf)
        FfiConverterOptionTypeL3dJointAxis.write(value.axis, into: &buf)
        FfiConverterOptionTypeVec3.write(value.defaultRotation, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dJoint_lift(_ buf: RustBuffer) throws -> L3dJoint {
    return try FfiConverterTypeL3dJoint.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dJoint_lower(_ value: L3dJoint) -> RustBuffer {
    return FfiConverterTypeL3dJoint.lower(value)
}


/**
 * A joint axis definition (for articulated luminaires)
 */
public struct L3dJointAxis {
    /**
     * Axis type: "x", "y", or "z"
     */
    public var axis: String
    /**
     * Minimum angle in degrees
     */
    public var min: Double
    /**
     * Maximum angle in degrees
     */
    public var max: Double
    /**
     * Step size in degrees
     */
    public var step: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Axis type: "x", "y", or "z"
         */axis: String, 
        /**
         * Minimum angle in degrees
         */min: Double, 
        /**
         * Maximum angle in degrees
         */max: Double, 
        /**
         * Step size in degrees
         */step: Double) {
        self.axis = axis
        self.min = min
        self.max = max
        self.step = step
    }
}



extension L3dJointAxis: Equatable, Hashable {
    public static func ==(lhs: L3dJointAxis, rhs: L3dJointAxis) -> Bool {
        if lhs.axis != rhs.axis {
            return false
        }
        if lhs.min != rhs.min {
            return false
        }
        if lhs.max != rhs.max {
            return false
        }
        if lhs.step != rhs.step {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(axis)
        hasher.combine(min)
        hasher.combine(max)
        hasher.combine(step)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeL3dJointAxis: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> L3dJointAxis {
        return
            try L3dJointAxis(
                axis: FfiConverterString.read(from: &buf), 
                min: FfiConverterDouble.read(from: &buf), 
                max: FfiConverterDouble.read(from: &buf), 
                step: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: L3dJointAxis, into buf: inout [UInt8]) {
        FfiConverterString.write(value.axis, into: &buf)
        FfiConverterDouble.write(value.min, into: &buf)
        FfiConverterDouble.write(value.max, into: &buf)
        FfiConverterDouble.write(value.step, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dJointAxis_lift(_ buf: RustBuffer) throws -> L3dJointAxis {
    return try FfiConverterTypeL3dJointAxis.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dJointAxis_lower(_ value: L3dJointAxis) -> RustBuffer {
    return FfiConverterTypeL3dJointAxis.lower(value)
}


/**
 * Light emitting object (LEO) in L3D
 */
public struct L3dLightEmittingObject {
    /**
     * Part name
     */
    public var partName: String
    /**
     * Position relative to parent
     */
    public var position: Vec3
    /**
     * Rotation in degrees
     */
    public var rotation: Vec3
    /**
     * Shape type: "circle" or "rectangle"
     */
    public var shapeType: String
    /**
     * Diameter for circle, or [width, height] for rectangle
     */
    public var shapeDimensions: [Double]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Part name
         */partName: String, 
        /**
         * Position relative to parent
         */position: Vec3, 
        /**
         * Rotation in degrees
         */rotation: Vec3, 
        /**
         * Shape type: "circle" or "rectangle"
         */shapeType: String, 
        /**
         * Diameter for circle, or [width, height] for rectangle
         */shapeDimensions: [Double]) {
        self.partName = partName
        self.position = position
        self.rotation = rotation
        self.shapeType = shapeType
        self.shapeDimensions = shapeDimensions
    }
}



extension L3dLightEmittingObject: Equatable, Hashable {
    public static func ==(lhs: L3dLightEmittingObject, rhs: L3dLightEmittingObject) -> Bool {
        if lhs.partName != rhs.partName {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.rotation != rhs.rotation {
            return false
        }
        if lhs.shapeType != rhs.shapeType {
            return false
        }
        if lhs.shapeDimensions != rhs.shapeDimensions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(partName)
        hasher.combine(position)
        hasher.combine(rotation)
        hasher.combine(shapeType)
        hasher.combine(shapeDimensions)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeL3dLightEmittingObject: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> L3dLightEmittingObject {
        return
            try L3dLightEmittingObject(
                partName: FfiConverterString.read(from: &buf), 
                position: FfiConverterTypeVec3.read(from: &buf), 
                rotation: FfiConverterTypeVec3.read(from: &buf), 
                shapeType: FfiConverterString.read(from: &buf), 
                shapeDimensions: FfiConverterSequenceDouble.read(from: &buf)
        )
    }

    public static func write(_ value: L3dLightEmittingObject, into buf: inout [UInt8]) {
        FfiConverterString.write(value.partName, into: &buf)
        FfiConverterTypeVec3.write(value.position, into: &buf)
        FfiConverterTypeVec3.write(value.rotation, into: &buf)
        FfiConverterString.write(value.shapeType, into: &buf)
        FfiConverterSequenceDouble.write(value.shapeDimensions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dLightEmittingObject_lift(_ buf: RustBuffer) throws -> L3dLightEmittingObject {
    return try FfiConverterTypeL3dLightEmittingObject.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dLightEmittingObject_lower(_ value: L3dLightEmittingObject) -> RustBuffer {
    return FfiConverterTypeL3dLightEmittingObject.lower(value)
}


/**
 * Complete L3D scene information
 */
public struct L3dScene {
    /**
     * Application that created this file
     */
    public var createdWithApplication: String
    /**
     * Creation timestamp
     */
    public var creationTimeCode: String
    /**
     * All geometry file definitions
     */
    public var geometryDefinitions: [L3dGeometryDef]
    /**
     * Flattened list of all scene parts with world transforms
     */
    public var parts: [L3dScenePart]
    /**
     * Joint definitions (for articulated luminaires)
     */
    public var joints: [L3dJoint]
    /**
     * Raw structure.xml content (for debugging)
     */
    public var rawStructureXml: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Application that created this file
         */createdWithApplication: String, 
        /**
         * Creation timestamp
         */creationTimeCode: String, 
        /**
         * All geometry file definitions
         */geometryDefinitions: [L3dGeometryDef], 
        /**
         * Flattened list of all scene parts with world transforms
         */parts: [L3dScenePart], 
        /**
         * Joint definitions (for articulated luminaires)
         */joints: [L3dJoint], 
        /**
         * Raw structure.xml content (for debugging)
         */rawStructureXml: String) {
        self.createdWithApplication = createdWithApplication
        self.creationTimeCode = creationTimeCode
        self.geometryDefinitions = geometryDefinitions
        self.parts = parts
        self.joints = joints
        self.rawStructureXml = rawStructureXml
    }
}



extension L3dScene: Equatable, Hashable {
    public static func ==(lhs: L3dScene, rhs: L3dScene) -> Bool {
        if lhs.createdWithApplication != rhs.createdWithApplication {
            return false
        }
        if lhs.creationTimeCode != rhs.creationTimeCode {
            return false
        }
        if lhs.geometryDefinitions != rhs.geometryDefinitions {
            return false
        }
        if lhs.parts != rhs.parts {
            return false
        }
        if lhs.joints != rhs.joints {
            return false
        }
        if lhs.rawStructureXml != rhs.rawStructureXml {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdWithApplication)
        hasher.combine(creationTimeCode)
        hasher.combine(geometryDefinitions)
        hasher.combine(parts)
        hasher.combine(joints)
        hasher.combine(rawStructureXml)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeL3dScene: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> L3dScene {
        return
            try L3dScene(
                createdWithApplication: FfiConverterString.read(from: &buf), 
                creationTimeCode: FfiConverterString.read(from: &buf), 
                geometryDefinitions: FfiConverterSequenceTypeL3dGeometryDef.read(from: &buf), 
                parts: FfiConverterSequenceTypeL3dScenePart.read(from: &buf), 
                joints: FfiConverterSequenceTypeL3dJoint.read(from: &buf), 
                rawStructureXml: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: L3dScene, into buf: inout [UInt8]) {
        FfiConverterString.write(value.createdWithApplication, into: &buf)
        FfiConverterString.write(value.creationTimeCode, into: &buf)
        FfiConverterSequenceTypeL3dGeometryDef.write(value.geometryDefinitions, into: &buf)
        FfiConverterSequenceTypeL3dScenePart.write(value.parts, into: &buf)
        FfiConverterSequenceTypeL3dJoint.write(value.joints, into: &buf)
        FfiConverterString.write(value.rawStructureXml, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dScene_lift(_ buf: RustBuffer) throws -> L3dScene {
    return try FfiConverterTypeL3dScene.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dScene_lower(_ value: L3dScene) -> RustBuffer {
    return FfiConverterTypeL3dScene.lower(value)
}


/**
 * A geometry part in the L3D scene hierarchy
 */
public struct L3dScenePart {
    /**
     * Part name
     */
    public var partName: String
    /**
     * Geometry definition ID
     */
    public var geometryId: String
    /**
     * Local position
     */
    public var position: Vec3
    /**
     * Local rotation (degrees)
     */
    public var rotation: Vec3
    /**
     * Pre-computed world transform matrix (column-major)
     */
    public var worldTransform: Matrix4
    /**
     * Scale factor based on units
     */
    public var scale: Double
    /**
     * Light emitting objects attached to this part
     */
    public var lightEmittingObjects: [L3dLightEmittingObject]
    /**
     * Face assignments for LEOs
     */
    public var faceAssignments: [L3dFaceAssignment]
    /**
     * Child joint names (for reference)
     */
    public var jointNames: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Part name
         */partName: String, 
        /**
         * Geometry definition ID
         */geometryId: String, 
        /**
         * Local position
         */position: Vec3, 
        /**
         * Local rotation (degrees)
         */rotation: Vec3, 
        /**
         * Pre-computed world transform matrix (column-major)
         */worldTransform: Matrix4, 
        /**
         * Scale factor based on units
         */scale: Double, 
        /**
         * Light emitting objects attached to this part
         */lightEmittingObjects: [L3dLightEmittingObject], 
        /**
         * Face assignments for LEOs
         */faceAssignments: [L3dFaceAssignment], 
        /**
         * Child joint names (for reference)
         */jointNames: [String]) {
        self.partName = partName
        self.geometryId = geometryId
        self.position = position
        self.rotation = rotation
        self.worldTransform = worldTransform
        self.scale = scale
        self.lightEmittingObjects = lightEmittingObjects
        self.faceAssignments = faceAssignments
        self.jointNames = jointNames
    }
}



extension L3dScenePart: Equatable, Hashable {
    public static func ==(lhs: L3dScenePart, rhs: L3dScenePart) -> Bool {
        if lhs.partName != rhs.partName {
            return false
        }
        if lhs.geometryId != rhs.geometryId {
            return false
        }
        if lhs.position != rhs.position {
            return false
        }
        if lhs.rotation != rhs.rotation {
            return false
        }
        if lhs.worldTransform != rhs.worldTransform {
            return false
        }
        if lhs.scale != rhs.scale {
            return false
        }
        if lhs.lightEmittingObjects != rhs.lightEmittingObjects {
            return false
        }
        if lhs.faceAssignments != rhs.faceAssignments {
            return false
        }
        if lhs.jointNames != rhs.jointNames {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(partName)
        hasher.combine(geometryId)
        hasher.combine(position)
        hasher.combine(rotation)
        hasher.combine(worldTransform)
        hasher.combine(scale)
        hasher.combine(lightEmittingObjects)
        hasher.combine(faceAssignments)
        hasher.combine(jointNames)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeL3dScenePart: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> L3dScenePart {
        return
            try L3dScenePart(
                partName: FfiConverterString.read(from: &buf), 
                geometryId: FfiConverterString.read(from: &buf), 
                position: FfiConverterTypeVec3.read(from: &buf), 
                rotation: FfiConverterTypeVec3.read(from: &buf), 
                worldTransform: FfiConverterTypeMatrix4.read(from: &buf), 
                scale: FfiConverterDouble.read(from: &buf), 
                lightEmittingObjects: FfiConverterSequenceTypeL3dLightEmittingObject.read(from: &buf), 
                faceAssignments: FfiConverterSequenceTypeL3dFaceAssignment.read(from: &buf), 
                jointNames: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: L3dScenePart, into buf: inout [UInt8]) {
        FfiConverterString.write(value.partName, into: &buf)
        FfiConverterString.write(value.geometryId, into: &buf)
        FfiConverterTypeVec3.write(value.position, into: &buf)
        FfiConverterTypeVec3.write(value.rotation, into: &buf)
        FfiConverterTypeMatrix4.write(value.worldTransform, into: &buf)
        FfiConverterDouble.write(value.scale, into: &buf)
        FfiConverterSequenceTypeL3dLightEmittingObject.write(value.lightEmittingObjects, into: &buf)
        FfiConverterSequenceTypeL3dFaceAssignment.write(value.faceAssignments, into: &buf)
        FfiConverterSequenceString.write(value.jointNames, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dScenePart_lift(_ buf: RustBuffer) throws -> L3dScenePart {
    return try FfiConverterTypeL3dScenePart.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeL3dScenePart_lower(_ value: L3dScenePart) -> RustBuffer {
    return FfiConverterTypeL3dScenePart.lower(value)
}


/**
 * 4x4 transformation matrix (column-major for OpenGL/Metal/SceneKit)
 */
public struct Matrix4 {
    /**
     * Matrix values in column-major order (m00, m10, m20, m30, m01, m11, ...)
     */
    public var values: [Double]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Matrix values in column-major order (m00, m10, m20, m30, m01, m11, ...)
         */values: [Double]) {
        self.values = values
    }
}



extension Matrix4: Equatable, Hashable {
    public static func ==(lhs: Matrix4, rhs: Matrix4) -> Bool {
        if lhs.values != rhs.values {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(values)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMatrix4: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Matrix4 {
        return
            try Matrix4(
                values: FfiConverterSequenceDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Matrix4, into buf: inout [UInt8]) {
        FfiConverterSequenceDouble.write(value.values, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrix4_lift(_ buf: RustBuffer) throws -> Matrix4 {
    return try FfiConverterTypeMatrix4.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrix4_lower(_ value: Matrix4) -> RustBuffer {
    return FfiConverterTypeMatrix4.lower(value)
}


/**
 * 3D vector
 */
public struct Vec3 {
    public var x: Double
    public var y: Double
    public var z: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(x: Double, y: Double, z: Double) {
        self.x = x
        self.y = y
        self.z = z
    }
}



extension Vec3: Equatable, Hashable {
    public static func ==(lhs: Vec3, rhs: Vec3) -> Bool {
        if lhs.x != rhs.x {
            return false
        }
        if lhs.y != rhs.y {
            return false
        }
        if lhs.z != rhs.z {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x)
        hasher.combine(y)
        hasher.combine(z)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVec3: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Vec3 {
        return
            try Vec3(
                x: FfiConverterDouble.read(from: &buf), 
                y: FfiConverterDouble.read(from: &buf), 
                z: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Vec3, into buf: inout [UInt8]) {
        FfiConverterDouble.write(value.x, into: &buf)
        FfiConverterDouble.write(value.y, into: &buf)
        FfiConverterDouble.write(value.z, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec3_lift(_ buf: RustBuffer) throws -> Vec3 {
    return try FfiConverterTypeVec3.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVec3_lower(_ value: Vec3) -> RustBuffer {
    return FfiConverterTypeVec3.lower(value)
}


public enum GldfError {

    
    
    case ParseError(msg: String
    )
    case SerializeError(msg: String
    )
    case FileNotFound(msg: String
    )
    case InvalidData(msg: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGldfError: FfiConverterRustBuffer {
    typealias SwiftType = GldfError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GldfError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParseError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .SerializeError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .FileNotFound(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 4: return .InvalidData(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GldfError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ParseError(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .SerializeError(msg):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .FileNotFound(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .InvalidData(msg):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


extension GldfError: Equatable, Hashable {}

extension GldfError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeL3dJointAxis: FfiConverterRustBuffer {
    typealias SwiftType = L3dJointAxis?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeL3dJointAxis.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeL3dJointAxis.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeVec3: FfiConverterRustBuffer {
    typealias SwiftType = Vec3?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVec3.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVec3.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceDouble: FfiConverterRustBuffer {
    typealias SwiftType = [Double]

    public static func write(_ value: [Double], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterDouble.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Double] {
        let len: Int32 = try readInt(&buf)
        var seq = [Double]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterDouble.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGldfFile: FfiConverterRustBuffer {
    typealias SwiftType = [GldfFile]

    public static func write(_ value: [GldfFile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGldfFile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GldfFile] {
        let len: Int32 = try readInt(&buf)
        var seq = [GldfFile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGldfFile.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGldfLightSource: FfiConverterRustBuffer {
    typealias SwiftType = [GldfLightSource]

    public static func write(_ value: [GldfLightSource], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGldfLightSource.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GldfLightSource] {
        let len: Int32 = try readInt(&buf)
        var seq = [GldfLightSource]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGldfLightSource.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGldfVariant: FfiConverterRustBuffer {
    typealias SwiftType = [GldfVariant]

    public static func write(_ value: [GldfVariant], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGldfVariant.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GldfVariant] {
        let len: Int32 = try readInt(&buf)
        var seq = [GldfVariant]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGldfVariant.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeL3dAsset: FfiConverterRustBuffer {
    typealias SwiftType = [L3dAsset]

    public static func write(_ value: [L3dAsset], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeL3dAsset.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [L3dAsset] {
        let len: Int32 = try readInt(&buf)
        var seq = [L3dAsset]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeL3dAsset.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeL3dFaceAssignment: FfiConverterRustBuffer {
    typealias SwiftType = [L3dFaceAssignment]

    public static func write(_ value: [L3dFaceAssignment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeL3dFaceAssignment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [L3dFaceAssignment] {
        let len: Int32 = try readInt(&buf)
        var seq = [L3dFaceAssignment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeL3dFaceAssignment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeL3dGeometryDef: FfiConverterRustBuffer {
    typealias SwiftType = [L3dGeometryDef]

    public static func write(_ value: [L3dGeometryDef], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeL3dGeometryDef.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [L3dGeometryDef] {
        let len: Int32 = try readInt(&buf)
        var seq = [L3dGeometryDef]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeL3dGeometryDef.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeL3dJoint: FfiConverterRustBuffer {
    typealias SwiftType = [L3dJoint]

    public static func write(_ value: [L3dJoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeL3dJoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [L3dJoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [L3dJoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeL3dJoint.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeL3dLightEmittingObject: FfiConverterRustBuffer {
    typealias SwiftType = [L3dLightEmittingObject]

    public static func write(_ value: [L3dLightEmittingObject], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeL3dLightEmittingObject.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [L3dLightEmittingObject] {
        let len: Int32 = try readInt(&buf)
        var seq = [L3dLightEmittingObject]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeL3dLightEmittingObject.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeL3dScenePart: FfiConverterRustBuffer {
    typealias SwiftType = [L3dScenePart]

    public static func write(_ value: [L3dScenePart], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeL3dScenePart.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [L3dScenePart] {
        let len: Int32 = try readInt(&buf)
        var seq = [L3dScenePart]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeL3dScenePart.read(from: &buf))
        }
        return seq
    }
}
/**
 * Get asset from L3D file by filename
 */
public func getL3dAsset(l3dFile: L3dFile, filename: String) -> Data? {
    return try!  FfiConverterOptionData.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_func_get_l3d_asset(
        FfiConverterTypeL3dFile.lower(l3dFile),
        FfiConverterString.lower(filename),$0
    )
})
}
/**
 * Get GLDF library version string
 */
public func gldfLibraryVersion() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_func_gldf_library_version($0
    )
})
}
/**
 * Parse GLDF from bytes and return JSON string
 */
public func gldfToJson(data: Data)throws  -> String {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_func_gldf_to_json(
        FfiConverterData.lower(data),$0
    )
})
}
/**
 * Parse EULUMDAT (LDT) file from string content
 */
public func parseEulumdat(content: String) -> EulumdatData {
    return try!  FfiConverterTypeEulumdatData.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_func_parse_eulumdat(
        FfiConverterString.lower(content),$0
    )
})
}
/**
 * Parse EULUMDAT from raw bytes
 */
public func parseEulumdatBytes(data: Data) -> EulumdatData {
    return try!  FfiConverterTypeEulumdatData.lift(try! rustCall() {
    uniffi_gldf_ffi_fn_func_parse_eulumdat_bytes(
        FfiConverterData.lower(data),$0
    )
})
}
/**
 * Parse L3D file from raw bytes (ZIP archive)
 */
public func parseL3d(data: Data)throws  -> L3dFile {
    return try  FfiConverterTypeL3dFile.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_func_parse_l3d(
        FfiConverterData.lower(data),$0
    )
})
}
/**
 * Parse L3D structure.xml content
 */
public func parseL3dStructure(xmlContent: String)throws  -> L3dScene {
    return try  FfiConverterTypeL3dScene.lift(try rustCallWithError(FfiConverterTypeGldfError.lift) {
    uniffi_gldf_ffi_fn_func_parse_l3d_structure(
        FfiConverterString.lower(xmlContent),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_gldf_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_gldf_ffi_checksum_func_get_l3d_asset() != 14912) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_func_gldf_library_version() != 12726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_func_gldf_to_json() != 54896) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_func_parse_eulumdat() != 59607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_func_parse_eulumdat_bytes() != 57283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_func_parse_l3d() != 37918) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_func_parse_l3d_structure() != 18908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_add_file() != 48678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_archive_file() != 13214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_file_content() != 58159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_file_content_as_string() != 22619) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_files() != 13639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_geometry_files() != 24591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_header() != 23906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_image_files() != 20408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_light_sources() != 56370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_photometric_files() != 795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_stats() != 47316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_get_variants() != 3574) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_has_archive_data() != 16000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_is_modified() != 6972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_list_archive_files() != 60453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_mark_saved() != 7540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_remove_file() != 14551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_set_author() != 1512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_set_created_with_application() != 57764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_set_creation_time_code() != 46771) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_set_default_language() != 17385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_set_format_version() != 5986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_set_manufacturer() != 5472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_to_json() != 53297) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_to_pretty_json() != 56730) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_to_xml() != 50708) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_method_gldfengine_update_file() != 10561) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_constructor_gldfengine_from_bytes() != 47328) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_constructor_gldfengine_from_json() != 36887) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_gldf_ffi_checksum_constructor_gldfengine_new_empty() != 19459) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
